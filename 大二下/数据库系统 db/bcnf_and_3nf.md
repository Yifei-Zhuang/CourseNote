寻找bcnf分解的方法；

	1. 首先遍历所有的关系，判断左侧的元组对于当前的子关系是不是候选键，如果不是，那么根据该FD进行分解，然后对于每一个子元组继续以上过程，也就是在每一个子元组中判断函数闭包中的所有关系的左侧是否都是候选键
	1. 当无法继续分解，那么实现了BCNF
1. 首先寻找候选键，对所有属性进行只在左侧出现，只在右侧出现，左右侧均出现的分类
2. 




寻找3nf的方法：

1. 将函数关系转化为最小正则覆盖，之后将所有的正则覆盖更改为子元组。
2. 检查所有元组，如果至少一个元组存在一组候选键，那么转到步骤三，否则在添加一个新的元组，其内容为随机候选键。
3. 之后除掉所有的冗余元组。



最小正则覆盖寻找方法：

1. 进入循环
2. 首先合并所有左侧相同的元组
3. 之后遍历所有的函数依赖，检查是否存在冗余变量
4. 直到一轮遍历下来没有发生任何变化，退出循环



检测变量是否是冗余的：

1. 变量在左侧

   如果其他FD能够推理出去掉该变量的FD，那么是冗余的

2. 变量在右侧

   如果去掉该变量之后，左侧元组的闭包仍然包含该变量，那么该变量是多余的

  
求属性闭包的方法：
	1. 如果左侧有多个属性，那么就将其括号括在一个方框内部
	2. 如果是右侧有多个属性，那么将其分解为单个属性


求函数闭包的方法；
	1. 首先列出所有的子集
	2. 之后表示出所有子集的属性闭包即可

求最小正则覆盖的方法：
	1. 根据函数依赖关系，绘制依赖图
	2. 去掉距离更大的关系（比如A -> B, A -> C, B -> C, 那么A -> C 更远，去掉A -> C依赖)
BCNF分解算法：
	1. 首先根绝给出出的函数依赖绘制出依赖图
	2. 之后，从根部向上遍历，逐个分解出子关系，最后直接将剩余的所有属性直接合并为一个集合，所有的属性都是主码的一部分

3NF分解算法；
	1. 首先获取最小正则覆盖
	2. 将所有的函数依赖关系转坏为关系集合
	3. 检查获取的关系集合，如果至少一个关系中存在候选键，那么跳转到第5步
	4. 如果不存在候选键，那么添加一个新的集合，该集合属性为任意一组候选键
	5. 去除重复的集合（比如ADE和AD），所得到的关系集合即为所需的3NF
